patterns:
- pattern: architecture/*
  insights:
  - The task required making cli.py explicitly import from parsers/ directory (ClaudeParser,
    CodexParser, VermasParser) even though core.py already had access. This explicit
    import pattern makes the CLI's dependencies visible and ensures the wiring is
    intentional rather than transitive.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - architecture
  - technical
  sample_count: 1
- pattern: git-workflow/*
  insights:
  - 'When code exists in git worktrees but was never committed to main, recover it
    by: (1) copying files from worktree to main, (2) running tests to verify functionality,
    (3) using ''git add'' explicitly on each deliverable file, (4) verifying tracking
    with ''git ls-files --error-unmatch'', (5) committing with descriptive message
    referencing the original action item IDs. This workflow recovered 2000+ lines
    of parser code (VerMAS: 830 lines, Codex: 514 lines) plus 1793 lines of tests.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - git-workflow
  - process
  sample_count: 1
- pattern: verification/*
  insights:
  - When dev discovers feature already exists ('CLI wiring was already complete'),
    the workflow should have an early exit path that marks the task as 'unnecessary'
    rather than continuing through QA. This saves ~50% of cycle time for redundant
    tasks.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - verification
  - process
  sample_count: 1
- pattern: testing/*
  insights:
  - QA initially failed pytest due to missing deps and pytest-cov addopts conflicts.
    Resolved by creating fresh venv with '. .venv/bin/activate && pip install .[dev]'.
    This pattern ensures clean test environment isolation from global Python state.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - testing
  - technical
  sample_count: 1
- pattern: code-recovery/*
  insights:
  - When integrating components developed in git worktrees, first verify and commit
    the code to main before wiring them into the core system. This workflow successfully
    recovered 1,140 lines of Codex parser code and 2,030 lines of VerMAS parser code
    that existed in worktrees but were never committed. The recovery step (commits
    d9e3b74, becde1e) preceded the integration step (commit 9d038df).
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - code-recovery
  - process
  sample_count: 1
- pattern: infrastructure/*
  insights:
  - 'The error message ''agents died. Dead roles: [watcher, dev, qa]'' provides no
    information about why the tmux session ended (timeout, user action, resource exhaustion,
    or system restart). Adding diagnostic logging before session teardown would enable
    root cause analysis.'
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - infrastructure
  - technical
  sample_count: 1
- pattern: error-handling/*
  insights:
  - The 'agents died' error should first check if the workflow has already completed
    via signals. In this case, all three roles had signaled success within 3 minutes
    (14:04-14:06) before the QA agent died. A pre-failure signal check would have
    correctly identified this as a successful completion with agent cleanup issue
    rather than a failed workflow.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - error-handling
  - technical
  sample_count: 1
- pattern: compatibility/*
  insights:
  - When two parts of a system use similar but incompatible data models, add compatibility
    properties to the newer model rather than changing all consumers. The BaseSession
    in parsers/models.py gained properties like 'id' (aliasing session_id), 'start_time'
    (aliasing timestamp), and 'tools_used' (converting tool_calls) to maintain compatibility
    with models/__init__.py:BaseSession consumers.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - compatibility
  - technical
  sample_count: 1
- pattern: workflow-reliability/*
  insights:
  - When an agent sends its final signal (done/approved/complete) and then terminates
    before the orchestrator acknowledges, the framework reports 'agents died' despite
    successful completion. The workflow recorded three successful signals (dev done
    at 14:04, QA approved at 14:06, watcher complete at 14:06) yet reported failure.
    Orchestrators should check for existing completion signals before declaring failure.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-reliability
  - technical
  sample_count: 1
- pattern: code-review/*
  insights:
  - When task requirements conflict with linter rules (e.g., required imports that
    appear unused), create usage patterns rather than removing the imports. In this
    workflow, QA first flagged unused imports (F401), then flagged that removing them
    violated requirements. The solution was adding a PARSERS dict that uses the imports,
    satisfying both constraints.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - code-review
  - process
  sample_count: 1
- pattern: dependencies/*
  insights:
  - 'Task required Click dependency but dev initially signaled done without it. QA
    caught this in first review cycle. Pattern: run ''uv sync'' or equivalent and
    verify imports work before claiming task completion. Dependencies are a common
    oversight in verification tasks.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - dependencies
  - technical
  sample_count: 1
- pattern: workflow-resilience/*
  insights:
  - When tmux sessions terminate unexpectedly, agents die without opportunity to save
    state or signal failure. This creates opaque failures reported as 'agents died'
    without diagnostic information. Long-running tasks are particularly vulnerable
    to this infrastructure failure mode.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-resilience
  - process
  sample_count: 1
- pattern: task-decomposition/*
  insights:
  - 'The task had exactly three acceptance criteria: (1) add --output argument with
    default, (2) create directory if missing, (3) print confirmation message. This
    atomic scope allowed dev to complete implementation quickly and QA to verify each
    criterion explicitly. Following the pattern from cycle-5, small focused tasks
    outperform monolithic implementations.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - task-decomposition
  - process
  sample_count: 1
- pattern: failure-recovery/*
  insights:
  - When cycle-4 'implement-cli-skeleton' failed, the system had already evolved a
    decomposition plan. Cycle-5 'add-analyze-subcommand-stub' succeeded with 186 tests
    passing. This validates that incremental task breakdown is an effective recovery
    strategy after infrastructure or scope failures.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - failure-recovery
  - process
  sample_count: 1
- pattern: performance/*
  insights:
  - When parsing file-discovery-based sources (like VerMAS scanning .vermas/ directories),
    implement a _parsed_dirs cache to track already-processed directories. Without
    this, scanning multiple files from the same source creates duplicate sessions
    in aggregated results. Add reset_cache() function for test isolation.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - performance
  - technical
  sample_count: 1
- pattern: debugging/*
  insights:
  - Before reimplementing failed features, run a diagnostic task to identify what's
    actually broken. This workflow diagnosed that CLI code was complete but misconfigured
    dependencies caused failures - saving time compared to rewriting working code.
    The diagnostic discovered the issue was a 1-line fix, not architectural.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - debugging
  - process
  sample_count: 1
- pattern: integration/*
  insights:
  - When adding new session sources to a discovery system, update SESSION_PATTERNS
    to include the new directory patterns (.claude/, .codex/, .vermas/) AND update
    parse_session_file() dispatch logic to route to the correct parser based on file
    path context. QA should explicitly verify both discovery and parsing for each
    new source.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - integration
  - technical
  sample_count: 1
- pattern: task-planning/*
  insights:
  - This workflow attempted 'implement-cli-skeleton' when cli.py already exists in
    git with multiple prior commits. Task backlog systems must query git (git ls-files
    --error-unmatch <deliverable>) before spawning agent workflows. Tasks targeting
    existing files should be auto-converted to 'enhance' or 'fix' tasks, or auto-closed
    entirely.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - task-planning
  - process
  sample_count: 1
- pattern: workflow-lifecycle/*
  insights:
  - At 4666 seconds (77+ minutes), all three agents (watcher, dev, qa) died simultaneously,
    indicating tmux session termination rather than individual agent failures. Workflows
    exceeding 30 minutes should implement session keepalive mechanisms or checkpoint-based
    recovery to survive infrastructure interruptions.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-lifecycle
  - process
  sample_count: 1
- pattern: specification-compliance/*
  insights:
  - Dev initially implemented with typer/rich/pydantic when spec explicitly required
    click>=8.0. Over-building creates drift from requirements and extra rework during
    QA. Always start with the minimal spec (dependencies explicitly listed in task
    definition) and resist adding conveniences not specified in requirements.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - specification-compliance
  - process
  sample_count: 1
- pattern: task-validation/*
  insights:
  - This cycle-4 workflow attempted to implement cli.py which already existed as 242
    lines of functional code in git main branch. Running 'git ls-files --error-unmatch
    src/session_insights/cli.py' would have returned success, indicating the task
    is stale. Task backlog systems should auto-validate deliverables exist before
    spawning expensive multi-agent workflows.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - task-validation
  - process
  sample_count: 1
- pattern: error-diagnostics/*
  insights:
  - 'The error ''agents died. Dead roles: [watcher, dev, qa]'' provides no information
    about why the tmux session ended (timeout, user action, resource exhaustion, or
    crash). Adding pre-termination hooks or periodic state snapshots would enable
    root cause analysis and distinguish recoverable from fatal failures.'
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - error-diagnostics
  - technical
  sample_count: 1
- pattern: task-backlog/*
  insights:
  - Tasks targeting files that already exist in git should be automatically converted
    to 'enhance' or 'fix' variants, or auto-closed with explanation. This prevents
    wasted compute on obsolete work and aligns the backlog with actual codebase state.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - task-backlog
  - process
  sample_count: 1
- pattern: workflow-coordination/*
  insights:
  - Using structured meetings with the create_meeting, say, and create_action_item
    tools allows agents to collaboratively investigate failures and document findings.
    The dev agent created 3 specific action items with clear descriptions and assigned
    roles, preserving institutional knowledge.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-coordination
  - process
  sample_count: 1
- pattern: cli-development/*
  insights:
  - 'When a task requires importing modules for future use but linters flag them as
    unused, create a registry pattern (like PARSERS = {''claude'': ClaudeParser, ...})
    that references the imports. This documents the intended mapping while satisfying
    static analysis.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - cli-development
  - technical
  sample_count: 1
- pattern: workflow/*
  insights:
  - 'The workflow demonstrated effective revision cycles: QA signaled ''needs_revision''
    when the required deliverable (docs/cli-diagnostic.md) was missing, and dev responded
    by creating it within seconds. This tight feedback loop ensures deliverables are
    actually produced before signaling completion.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow
  - process
  sample_count: 1
- pattern: workflow-signals/*
  insights:
  - Both dev and QA used descriptive signal messages explaining exactly what was done
    or what needed revision. QA's 'needs_revision' messages specified the exact discrepancy
    ('Click default vs spec'), allowing dev to fix precisely without back-and-forth
    clarification.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-signals
  - process
  sample_count: 1
- pattern: discovery/*
  insights:
  - Before implementing any task, agents should first check if the deliverable already
    exists. In this workflow, the dev agent correctly identified that the directory
    structure was already present and reported verification instead of attempting
    recreation. This avoids duplicate work and maintains idempotency.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - discovery
  - process
  sample_count: 1
- pattern: recovery/*
  insights:
  - Even when workflow orchestration fails, code written in git worktrees is preserved
    and can be recovered. The investigation found a complete implementation with passing
    tests in .worktrees/implement-claude-parser/ that just needed to be committed.
    Always check worktrees before re-implementing failed tasks.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - recovery
  - technical
  sample_count: 1
- pattern: observability/*
  insights:
  - 'Workflow failures can occur at multiple levels: code implementation, test execution,
    commit/merge operations, or orchestration (agent registration, signal delivery).
    The root cause analysis identified MCP connection refused errors and missing agent
    registrations as orchestration issues, not code issues.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - observability
  - process
  sample_count: 1
- pattern: resilience/*
  insights:
  - When agents complete work but fail to signal completion, the work is lost if not
    committed. Consider implementing WIP (work-in-progress) commits before signaling
    done, so that even if signaling fails, the implementation is preserved in git
    history for recovery.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - resilience
  - process
  sample_count: 1
- pattern: git/*
  insights:
  - Always run explicit `git add` for deliverable files and verify with `git ls-files
    --error-unmatch` before signaling done. The common failure mode is creating files
    in the working directory without committing them, which breaks the 'done means
    committed to main' principle.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - git
  - technical
  sample_count: 1
- pattern: process/*
  insights:
  - 'Effective QA feedback includes specific failure details (test names, error messages,
    exact requirements missing). QA provided ''needs_revision'' signals with actionable
    items: ''missing Click dependency'', then ''pytest failed with 2 failures in tests/parsers/test_vermas.py''.
    This specificity enabled dev to fix issues quickly across 2 iteration cycles.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - process
  - process
  sample_count: 1
- pattern: workflow-management/*
  insights:
  - This workflow completed successfully (QA approved, commit made) but was reported
    as 'failure' due to 'agents died' when tmux sessions ended. Workflow success should
    be determined by signal state (complete/approved) rather than agent session liveness.
    Final state showed watcher reporting successful completion.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-management
  - process
  sample_count: 1
- pattern: qa-feedback/*
  insights:
  - 'QA provided specific, actionable feedback in each needs_revision signal: exact
    file paths, exact issue (ruff F401), and exact requirement reference. This specificity
    enabled dev to address issues in under 2 minutes per cycle rather than requiring
    clarification rounds.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - qa-feedback
  - process
  sample_count: 1
- pattern: workflow-efficiency/*
  insights:
  - The 636-second total duration included initial implementation plus two QA feedback
    cycles. Signal-based communication (done, needs_revision, done, needs_revision,
    done, approved, complete) kept context clear and transitions fast without synchronous
    meetings.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-efficiency
  - process
  sample_count: 1
- pattern: gate-0-validation/*
  insights:
  - The dev agent discovered CLI wiring was already complete (discover_sessions, parse_session_file
    routing). This demonstrates Gate 0 failure - the task was assigned without verifying
    the feature didn't already exist. A pre-planning check like 'git ls-files --error-unmatch'
    or code grep for the feature would have caught this before workflow launch.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - gate-0-validation
  - process
  sample_count: 1
- pattern: agent-reliability/*
  insights:
  - QA agent signaled 'approved' at 14:56:11, then dev signaled 'done' at 14:57:22,
    watcher signaled 'complete' at 14:57:47. Yet workflow failed because QA agent
    died afterward. The orchestrator should treat post-completion agent death differently
    than mid-task failure, preserving the success state.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - agent-reliability
  - process
  sample_count: 1
- pattern: documentation/*
  insights:
  - The diagnostic report included clear verification steps (test import without dev
    deps, test CLI execution, run test suite) that allow QA or future developers to
    confirm fixes work. This makes the diagnostic actionable rather than just informational.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - documentation
  - technical
  sample_count: 1
