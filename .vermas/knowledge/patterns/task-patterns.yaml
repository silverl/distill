patterns:
- pattern: architecture/*
  insights:
  - Creating derive_project_from_cwd() in a shared project_utils.py module allowed
    claude.py, codex.py, and vermas.py parsers to all use identical project detection
    logic, replacing three separate naive Path(cwd).name implementations. This pattern
    of extracting shared utilities from duplicated parser logic reduces inconsistencies
    and makes edge case fixes (like home directory rejection) apply uniformly across
    all parsers.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - architecture
  - technical
  sample_count: 1
- pattern: git-workflow/*
  insights:
  - The workflow produced 716 LOC on branch task/negative-path-cli-tests-mission-73116471-*
    but the code remains unmerged to main (only branch diff shows the file). This
    is the 10th occurrence of the merge-drops-source / branch-not-merged pattern.
    The direct-to-main commit mandate exists precisely to prevent this, but worktree-based
    workflows still create branches instead of committing directly to main.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - git-workflow
  - process
  sample_count: 1
- pattern: verification/*
  insights:
  - The pre-signal-check.sh script's artifact-only detection compares main..HEAD,
    which passes if ANY prior commit on the branch has src/tests changes. This allows
    artifact-only commits to slip through when prior successful commits exist. The
    fix is to compare HEAD~1..HEAD to verify the most recent commit itself contains
    source changes.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - verification
  - technical
  sample_count: 1
- pattern: testing/*
  insights:
  - 'The project_utils.py test suite demonstrates a thorough approach to path-based
    functionality testing: known parent directories (github, projects, repos), case
    insensitivity, trailing slashes, nested paths, and invalid paths (root, home dirs,
    system dirs like /tmp, /var). Testing 18 distinct path patterns caught the home
    directory bug before release. This pattern of exhaustive path normalization testing
    should be applied to any filesystem-path-dependent logic.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - testing
  - technical
  sample_count: 1
- pattern: code-recovery/*
  insights:
  - When integrating components developed in git worktrees, first verify and commit
    the code to main before wiring them into the core system. This workflow successfully
    recovered 1,140 lines of Codex parser code and 2,030 lines of VerMAS parser code
    that existed in worktrees but were never committed. The recovery step (commits
    d9e3b74, becde1e) preceded the integration step (commit 9d038df).
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - code-recovery
  - process
  sample_count: 1
- pattern: infrastructure/*
  insights:
  - 'The error message ''agents died. Dead roles: [watcher, dev, qa]'' provides no
    information about why the tmux session ended (timeout, user action, resource exhaustion,
    or system restart). Adding diagnostic logging before session teardown would enable
    root cause analysis.'
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - infrastructure
  - technical
  sample_count: 1
- pattern: error-handling/*
  insights:
  - The 'agents died' error should first check if the workflow has already completed
    via signals. In this case, all three roles had signaled success within 3 minutes
    (14:04-14:06) before the QA agent died. A pre-failure signal check would have
    correctly identified this as a successful completion with agent cleanup issue
    rather than a failed workflow.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - error-handling
  - technical
  sample_count: 1
- pattern: compatibility/*
  insights:
  - When two parts of a system use similar but incompatible data models, add compatibility
    properties to the newer model rather than changing all consumers. The BaseSession
    in parsers/models.py gained properties like 'id' (aliasing session_id), 'start_time'
    (aliasing timestamp), and 'tools_used' (converting tool_calls) to maintain compatibility
    with models/__init__.py:BaseSession consumers.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - compatibility
  - technical
  sample_count: 1
- pattern: workflow-reliability/*
  insights:
  - When an agent sends its final signal (done/approved/complete) and then terminates
    before the orchestrator acknowledges, the framework reports 'agents died' despite
    successful completion. The workflow recorded three successful signals (dev done
    at 14:04, QA approved at 14:06, watcher complete at 14:06) yet reported failure.
    Orchestrators should check for existing completion signals before declaring failure.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-reliability
  - technical
  sample_count: 1
- pattern: code-review/*
  insights:
  - QA identified that derive_project_from_cwd() incorrectly returned usernames for
    home directory paths like /Users/dev and /home/user, contradicting the function's
    own docstring. The dev fixed this within 3 minutes by adding _is_home_directory()
    and 3 targeted tests. This pattern shows QA adds genuine value by testing boundary
    conditions the original developer overlooked, and rapid turnaround is possible
    when the fix scope is clearly specified.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - code-review
  - process
  sample_count: 1
- pattern: dependencies/*
  insights:
  - 'Task required Click dependency but dev initially signaled done without it. QA
    caught this in first review cycle. Pattern: run ''uv sync'' or equivalent and
    verify imports work before claiming task completion. Dependencies are a common
    oversight in verification tasks.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - dependencies
  - technical
  sample_count: 1
- pattern: workflow-resilience/*
  insights:
  - When tmux sessions terminate unexpectedly, agents die without opportunity to save
    state or signal failure. This creates opaque failures reported as 'agents died'
    without diagnostic information. Long-running tasks are particularly vulnerable
    to this infrastructure failure mode.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-resilience
  - process
  sample_count: 1
- pattern: task-decomposition/*
  insights:
  - 'The task had exactly three acceptance criteria: (1) add --output argument with
    default, (2) create directory if missing, (3) print confirmation message. This
    atomic scope allowed dev to complete implementation quickly and QA to verify each
    criterion explicitly. Following the pattern from cycle-5, small focused tasks
    outperform monolithic implementations.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - task-decomposition
  - process
  sample_count: 1
- pattern: failure-recovery/*
  insights:
  - When cycle-4 'implement-cli-skeleton' failed, the system had already evolved a
    decomposition plan. Cycle-5 'add-analyze-subcommand-stub' succeeded with 186 tests
    passing. This validates that incremental task breakdown is an effective recovery
    strategy after infrastructure or scope failures.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - failure-recovery
  - process
  sample_count: 1
- pattern: performance/*
  insights:
  - When parsing file-discovery-based sources (like VerMAS scanning .vermas/ directories),
    implement a _parsed_dirs cache to track already-processed directories. Without
    this, scanning multiple files from the same source creates duplicate sessions
    in aggregated results. Add reset_cache() function for test isolation.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - performance
  - technical
  sample_count: 1
- pattern: debugging/*
  insights:
  - "For the 8th consecutive time, the merge from task branch to main dropped all\
    \ src/ and tests/ changes, producing an artifact-only commit (c41a3a3) containing\
    \ only .vermas/ state files, .coverage, and .worktrees/ entries. The branch (5590645)\
    \ retains the +849 LOC. The root cause appears to be in the automated merge/commit\
    \ process that constructs the main commit \u2014 it selectively stages .vermas/\
    \ artifacts but not source code. This is now the project's #1 systemic issue with\
    \ ~2,041 LOC stranded across 4 branches."
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - debugging
  - process
  sample_count: 1
- pattern: integration/*
  insights:
  - When adding new session sources to a discovery system, update SESSION_PATTERNS
    to include the new directory patterns (.claude/, .codex/, .vermas/) AND update
    parse_session_file() dispatch logic to route to the correct parser based on file
    path context. QA should explicitly verify both discovery and parsing for each
    new source.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - integration
  - technical
  sample_count: 1
- pattern: task-planning/*
  insights:
  - This workflow attempted 'implement-cli-skeleton' when cli.py already exists in
    git with multiple prior commits. Task backlog systems must query git (git ls-files
    --error-unmatch <deliverable>) before spawning agent workflows. Tasks targeting
    existing files should be auto-converted to 'enhance' or 'fix' tasks, or auto-closed
    entirely.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - task-planning
  - process
  sample_count: 1
- pattern: workflow-lifecycle/*
  insights:
  - "When agents complete their work and signal done/approved/complete but their tmux\
    \ sessions terminate before the state machine can cleanly transition, the workflow\
    \ is marked as 'failure' with 'agents died' even though all deliverables were\
    \ produced. The state machine should check signal state before declaring failure\
    \ on agent death \u2014 if all required signals (done, approved, complete) are\
    \ present, the workflow succeeded regardless of agent process state."
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-lifecycle
  - process
  sample_count: 1
- pattern: specification-compliance/*
  insights:
  - Dev initially implemented with typer/rich/pydantic when spec explicitly required
    click>=8.0. Over-building creates drift from requirements and extra rework during
    QA. Always start with the minimal spec (dependencies explicitly listed in task
    definition) and resist adding conveniences not specified in requirements.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - specification-compliance
  - process
  sample_count: 1
- pattern: task-validation/*
  insights:
  - The obsidian formatter was marked as status:done in the task backlog (implement-obsidian-formatter.md)
    yet a new workflow attempted to add it. Task orchestration should cross-reference
    backlog status and git file existence before spawning workflows. The existing
    file tracking showed obsidian.py committed in multiple prior commits.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - task-validation
  - process
  sample_count: 1
- pattern: error-diagnostics/*
  insights:
  - 'The error ''agents died. Dead roles: [watcher, dev, qa]'' provides no information
    about why the tmux session ended (timeout, user action, resource exhaustion, or
    crash). Adding pre-termination hooks or periodic state snapshots would enable
    root cause analysis and distinguish recoverable from fatal failures.'
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - error-diagnostics
  - technical
  sample_count: 1
- pattern: task-backlog/*
  insights:
  - Tasks targeting files that already exist in git should be automatically converted
    to 'enhance' or 'fix' variants, or auto-closed with explanation. This prevents
    wasted compute on obsolete work and aligns the backlog with actual codebase state.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - task-backlog
  - process
  sample_count: 1
- pattern: workflow-coordination/*
  insights:
  - "QA agent reviewed the base commit state before dev had finished implementing,\
    \ correctly finding no source changes and signaling needs_revision. The watcher\
    \ correctly identified this as normal (dev still working). However, this early\
    \ needs_revision signal is noise \u2014 the workflow should gate QA review on\
    \ dev's done signal rather than allowing QA to review intermediate states."
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-coordination
  - process
  sample_count: 1
- pattern: cli-development/*
  insights:
  - 'When a task requires importing modules for future use but linters flag them as
    unused, create a registry pattern (like PARSERS = {''claude'': ClaudeParser, ...})
    that references the imports. This documents the intended mapping while satisfying
    static analysis.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - cli-development
  - technical
  sample_count: 1
- pattern: workflow/*
  insights:
  - "Two workflows ran concurrently \u2014 narrative-quality-measurer succeeded in\
    \ getting source code onto main (a5a01caa has src/ changes), while project-detection-measurer\
    \ failed despite identical workflow structure. The inconsistency suggests the\
    \ merge failure is timing or ordering dependent rather than a deterministic bug.\
    \ When multiple worktree-based tasks complete near-simultaneously, some 'Complete\
    \ task' commits capture source code while others capture only artifacts."
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow
  - process
  sample_count: 1
- pattern: workflow-signals/*
  insights:
  - The pre-signal-check.sh script (fixed in 33f3b78 to check HEAD~1..HEAD) still
    cannot detect when a completion commit omits source changes that exist on the
    task branch. It only checks if the latest commit has source diffs vs main, not
    whether the task branch's source changes were included. A new check comparing
    'git diff main..task-branch -- src/ tests/' would catch this.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-signals
  - technical
  sample_count: 1
- pattern: discovery/*
  insights:
  - Before implementing any task, agents should first check if the deliverable already
    exists. In this workflow, the dev agent correctly identified that the directory
    structure was already present and reported verification instead of attempting
    recreation. This avoids duplicate work and maintains idempotency.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - discovery
  - process
  sample_count: 1
- pattern: recovery/*
  insights:
  - When code exists in worktrees or branches but was never merged to main, use selective
    file recovery (git checkout or file copy) rather than reimplementing from scratch.
    This workflow recovered 716 LOC of tests from an untracked worktree in one commit,
    avoiding the multi-cycle reimplementation attempts that had previously failed.
    Recovery preserves battle-tested code that was already written and reviewed.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - recovery
  - process
  sample_count: 1
- pattern: observability/*
  insights:
  - 'Workflow failures can occur at multiple levels: code implementation, test execution,
    commit/merge operations, or orchestration (agent registration, signal delivery).
    The root cause analysis identified MCP connection refused errors and missing agent
    registrations as orchestration issues, not code issues.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - observability
  - process
  sample_count: 1
- pattern: resilience/*
  insights:
  - When agents complete work but fail to signal completion, the work is lost if not
    committed. Consider implementing WIP (work-in-progress) commits before signaling
    done, so that even if signaling fails, the implementation is preserved in git
    history for recovery.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - resilience
  - process
  sample_count: 1
- pattern: git/*
  insights:
  - Always run explicit `git add` for deliverable files and verify with `git ls-files
    --error-unmatch` before signaling done. The common failure mode is creating files
    in the working directory without committing them, which breaks the 'done means
    committed to main' principle.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - git
  - technical
  sample_count: 1
- pattern: process/*
  insights:
  - "The pre-signal-check.sh script (which validates deliverables before signaling\
    \ done) did not catch the uncommitted-completion failure mode where work exists\
    \ in a worktree but isn't committed. This represents a gap in the verification\
    \ pipeline \u2014 the script checks git status on the main branch but doesn't\
    \ detect code sitting in worktrees. Pre-signal validation should verify that all\
    \ deliverable files are tracked in git on the current branch, not just that the\
    \ working tree is clean."
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - process
  - process
  sample_count: 1
- pattern: workflow-management/*
  insights:
  - This workflow completed successfully (QA approved, commit made) but was reported
    as 'failure' due to 'agents died' when tmux sessions ended. Workflow success should
    be determined by signal state (complete/approved) rather than agent session liveness.
    Final state showed watcher reporting successful completion.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-management
  - process
  sample_count: 1
- pattern: qa-feedback/*
  insights:
  - 'QA provided specific, actionable feedback in each needs_revision signal: exact
    file paths, exact issue (ruff F401), and exact requirement reference. This specificity
    enabled dev to address issues in under 2 minutes per cycle rather than requiring
    clarification rounds.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - qa-feedback
  - process
  sample_count: 1
- pattern: workflow-efficiency/*
  insights:
  - The 636-second total duration included initial implementation plus two QA feedback
    cycles. Signal-based communication (done, needs_revision, done, needs_revision,
    done, approved, complete) kept context clear and transitions fast without synchronous
    meetings.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-efficiency
  - process
  sample_count: 1
- pattern: gate-0-validation/*
  insights:
  - The task 'add-obsidian-formatter' targeted src/session_insights/formatters/obsidian.py
    which already exists as a 10KB file with 17KB of compiled bytecode. Running 'git
    ls-files --error-unmatch src/session_insights/formatters/obsidian.py' before workflow
    launch would have detected this immediately. This is the same Gate 0 failure pattern
    observed in cycles 5-12.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - gate-0-validation
  - process
  sample_count: 1
- pattern: agent-reliability/*
  insights:
  - QA agent signaled 'approved' at 14:56:11, then dev signaled 'done' at 14:57:22,
    watcher signaled 'complete' at 14:57:47. Yet workflow failed because QA agent
    died afterward. The orchestrator should treat post-completion agent death differently
    than mid-task failure, preserving the success state.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - agent-reliability
  - process
  sample_count: 1
- pattern: documentation/*
  insights:
  - The diagnostic report included clear verification steps (test import without dev
    deps, test CLI execution, run test suite) that allow QA or future developers to
    confirm fixes work. This makes the diagnostic actionable rather than just informational.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - documentation
  - technical
  sample_count: 1
- pattern: pydantic/*
  insights:
  - When a Pydantic subclass needs different calculation logic than its base class
    property, add an explicit property override in the subclass. VermasSession.duration_minutes
    was added to override BaseSession's calculation that returned 0/Unknown for sessions
    with different time field semantics.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - pydantic
  - technical
  sample_count: 1
- pattern: validation/*
  insights:
  - 'Effective CLI validation verifies: (1) entry point executes without import errors,
    (2) parser produces expected session counts from real data, (3) output format
    has valid structure (YAML frontmatter, markdown), (4) aggregations calculate correctly
    (durations, counts). This 4-point check validated parse_success_rate and obsidian_compatibility
    KPIs.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - validation
  - process
  sample_count: 1
- pattern: cli/*
  insights:
  - The sessions command outputs structured JSON (session_count, total_messages, date_range,
    sources) rather than formatted text. This enables piping output to other tools
    (jq, scripts) and makes the CLI composable. For discovery/listing commands, JSON
    is preferable to human-readable output.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - cli
  - technical
  sample_count: 1
- pattern: task-design/*
  insights:
  - When a task specifies 'implement X' but X already exists (different framework/approach),
    the dev agent successfully pivoted from 'create with Click' to 'fix existing Typer
    entry point'. This preserved working code and avoided introducing regressions.
    Tasks should include a discovery step to check existing state before prescribing
    implementation details.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - task-design
  - process
  sample_count: 1
- pattern: gate-checking/*
  insights:
  - Before starting an implementation task, Gate 0 must confirm the deliverable does
    not already exist in the codebase. In this workflow, the 'implement-analyze-command'
    task failed because the analyze command already existed from cycle 16 (commit
    5a0f625). A simple `git ls-files --error-unmatch` check or code search would have
    caught this before any work began.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - gate-checking
  - process
  sample_count: 1
- pattern: commits/*
  insights:
  - A commit that modifies only workflow artifacts (.yaml, .md, __pycache__) without
    changing any source code or test files is an artifact-only commit. Commit d2194b7
    claimed to 'Implement analyze CLI command with full pipeline' but contained 0
    src/test changes. Post-execution verification must diff src/ and tests/ directories
    against the parent commit, not against main, to catch this pattern.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - commits
  - process
  sample_count: 1
- pattern: action-items/*
  insights:
  - Action items act-2d5f5e36 (fix pre-signal-check.sh) and act-4b987d19 (create pre-task-check.sh)
    would have prevented this failure but remained unexecuted for 3+ cycles. The systemic
    issue is that task planners create new tasks instead of pulling from the action
    item backlog, causing the same failure modes to recur. Future workflows should
    check pending action items before planning new work.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - action-items
  - process
  sample_count: 1
- pattern: workflow-design/*
  insights:
  - "This workflow completed with 'success' status in 362 seconds, but the actual\
    \ outcome was a failed delivery \u2014 an artifact-only commit with zero source\
    \ code changes. Workflow orchestration should distinguish between process completion\
    \ (all steps ran) and value delivery (deliverables contain real changes). A post-merge\
    \ source diff check is essential."
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-design
  - process
  sample_count: 1
- pattern: deployment/*
  insights:
  - Despite successful implementation (496+ LOC), QA approval, and 468 passing tests,
    the 'Complete task' commit (a08504fa) on main contains only workflow artifacts
    (signals, session logs, .coverage files) with zero changes to src/ or tests/ directories.
    The actual source code exists only on the task branch (commits e0489822, fb46d9a0).
    This is the 10th occurrence of the merge-drops-source pattern, proving the worktree/branch
    merge workflow systematically fails to get source code onto main.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - deployment
  - process
  sample_count: 1
- pattern: workflow-automation/*
  insights:
  - 'Three action items from prior reviews (act-8c5932eb: .gitignore cleanup, act-2d5f5e36:
    pre-signal-check.sh fix, coverage fix) were finally executed as direct commits
    (8269907, 33f3b78, eb44c93) immediately after the M2e-C3 review. This broke the
    pattern of action items never being executed by treating them as standalone fixes
    rather than routing through the full workflow cycle.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-automation
  - process
  sample_count: 1
- pattern: implementation/*
  insights:
  - The dev agent produced a well-structured analyze subcommand with compute_richness_score(),
    compute_field_coverage(), --stats-only flag for JSON output, and comprehensive
    tests (+327 LOC tests across 3 files). The implementation follows established
    patterns (Typer + Rich) and properly handles edge cases (UTC normalization, file
    vs directory input, unparseable sessions). This quality of work is wasted when
    it doesn't reach main.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - implementation
  - technical
  sample_count: 1
- pattern: refactoring/*
  insights:
  - 'The successful approach was: (1) move shared type definitions from the specialized
    module (vermas.py) to the base module (models.py), (2) extend BaseSession with
    new fields using Optional/default-empty-list patterns, (3) update the specialized
    class to inherit rather than redefine, (4) add model_post_init() to auto-derive
    computed fields. This 4-step pattern achieved +141/-77 LOC (net +64) with zero
    test regressions across 218 tests.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - refactoring
  - technical
  sample_count: 1
- pattern: code-delivery/*
  insights:
  - "The 'Complete task' commits (d30eed2, 67b9e77) are workflow artifact commits\
    \ that contain only .vermas/ state files, .coverage, and .worktrees pointers \u2014\
    \ zero source code. When dev work happens on a branch, the completion commit must\
    \ be a merge commit that includes the branch's source changes. The automated-kpi-measurers\
    \ task avoided this because dev committed source directly to main during QA iteration,\
    \ so the completion commit only needed artifacts. The formatter task failed because\
    \ source was on branch 6ea299c and the completion commit (67b9e77) was not a merge."
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - code-delivery
  - process
  sample_count: 1
- pattern: qa-workflow/*
  insights:
  - 'QA agent (Codex) provided two rounds of precise, actionable feedback: Round 1
    identified that measurers should run CLI and parse generated files (not format
    sessions directly) and flagged timestamp field mismatches. Round 2 caught a spec
    mismatch (task_description checking always-present marker instead of actual content)
    and environment issues. Dev fixed both rounds quickly (9 minutes and 4 minutes
    respectively). The specificity of QA feedback (exact field names, exact test commands,
    exact error descriptions) enabled rapid turnaround.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - qa-workflow
  - process
  sample_count: 1
- pattern: quality-assurance/*
  insights:
  - "QA agent reviewed the branch early (signal bb8e1b75 at T+0) and correctly identified\
    \ 'branch has no code changes vs main' before dev had implemented anything, issuing\
    \ needs_revision. Dev then implemented the full feature and signaled done ~6 minutes\
    \ later. This early QA catch is a positive pattern \u2014 QA should review before\
    \ dev signals done to catch setup issues, but it also means QA ran before there\
    \ was code to review, wasting a review cycle."
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - quality-assurance
  - process
  sample_count: 1
- pattern: code-quality/*
  insights:
  - 'The formatter implementation demonstrates a reusable pattern for extracting structured
    sections (user questions, tool usage analysis, key decisions, accomplishments)
    from unstructured conversation turns. Key technique: use role-based filtering,
    keyword/marker-based decision extraction (''decided to'', ''chose to'', ''going
    to''), and tool_call metadata for context enrichment. Each extraction method is
    a separate private method with truncation guards (200 chars for questions, 150
    for decisions, 60 for tool args).'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - code-quality
  - technical
  sample_count: 1
- pattern: workflow-orchestration/*
  insights:
  - Despite the established direct-to-main mandate (8/8 success rate vs 0/9 for branch
    merges), the worktree-based workflow inherently creates a branch for the dev agent
    to commit to. The workflow infrastructure itself creates the conditions for the
    merge-drops-source failure mode. Workflow DSL needs to either commit directly
    to main or include an explicit merge-to-main step before signaling complete.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-orchestration
  - process
  sample_count: 1
- pattern: delivery/*
  insights:
  - "When agents work in git worktrees, their commits land on task branches rather\
    \ than main. This is the 'uncommitted-completion' failure mode \u2014 the work\
    \ exists but not where it needs to be. The dev agent committed 716 LOC of tests\
    \ to the worktree branch (c68657b) which required a separate recovery commit (636affe)\
    \ to get onto main. Agents working in worktrees must be explicitly instructed\
    \ to commit directly to main or the workflow should include a merge-to-main step."
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - delivery
  - process
  sample_count: 1
- pattern: environment/*
  insights:
  - QA agent's initial pytest run failed because dev dependencies weren't installed
    in QA's environment. The QA agent had to install deps before running tests. Workflows
    should ensure all agents share the same virtual environment or include environment
    setup as a prerequisite step, especially when QA needs to run the same test suite
    the dev agent created.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - environment
  - process
  sample_count: 1
