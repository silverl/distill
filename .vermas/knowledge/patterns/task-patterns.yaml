patterns:
- pattern: architecture/*
  insights:
  - The workflow unified two incompatible BaseSession classes and moved scattered
    type definitions (AgentSignal, AgentLearning, KnowledgeImprovement) into a single
    canonical location (parsers/models.py) before downstream feature work could proceed.
    This architectural prerequisite unblocked 3 dependent tasks (formatter, analyze
    subcommand, integration tests). Centralizing shared models eliminates getattr
    fallbacks and enables direct attribute access, improving type safety and maintainability.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - architecture
  - technical
  sample_count: 1
- pattern: git-workflow/*
  insights:
  - The pattern shows completion commits (c9e60c9) are created as new commits on main
    that cherry-pick only artifacts, rather than merge commits that incorporate the
    full task branch. A proper git merge --no-ff of the task branch would preserve
    all source changes. The successful C1-new cycle used this approach (merge commit
    6eec1c4 brought 56e97f6's code to main). The workflow should enforce 'git merge
    --no-ff task-branch' as the completion step.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - git-workflow
  - process
  sample_count: 1
- pattern: verification/*
  insights:
  - The pre-signal-check.sh script's artifact-only detection compares main..HEAD,
    which passes if ANY prior commit on the branch has src/tests changes. This allows
    artifact-only commits to slip through when prior successful commits exist. The
    fix is to compare HEAD~1..HEAD to verify the most recent commit itself contains
    source changes.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - verification
  - technical
  sample_count: 1
- pattern: testing/*
  insights:
  - "When moving model classes between modules, the primary regression risk is stale\
    \ imports. This workflow updated imports in 4 source files and 2 test files. The\
    \ test suite (218 tests) served as an effective safety net \u2014 any missed import\
    \ would cause immediate ImportError failures. Running the full test suite after\
    \ each move ensures no import paths are missed."
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - testing
  - technical
  sample_count: 1
- pattern: code-recovery/*
  insights:
  - When integrating components developed in git worktrees, first verify and commit
    the code to main before wiring them into the core system. This workflow successfully
    recovered 1,140 lines of Codex parser code and 2,030 lines of VerMAS parser code
    that existed in worktrees but were never committed. The recovery step (commits
    d9e3b74, becde1e) preceded the integration step (commit 9d038df).
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - code-recovery
  - process
  sample_count: 1
- pattern: infrastructure/*
  insights:
  - 'The error message ''agents died. Dead roles: [watcher, dev, qa]'' provides no
    information about why the tmux session ended (timeout, user action, resource exhaustion,
    or system restart). Adding diagnostic logging before session teardown would enable
    root cause analysis.'
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - infrastructure
  - technical
  sample_count: 1
- pattern: error-handling/*
  insights:
  - The 'agents died' error should first check if the workflow has already completed
    via signals. In this case, all three roles had signaled success within 3 minutes
    (14:04-14:06) before the QA agent died. A pre-failure signal check would have
    correctly identified this as a successful completion with agent cleanup issue
    rather than a failed workflow.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - error-handling
  - technical
  sample_count: 1
- pattern: compatibility/*
  insights:
  - When two parts of a system use similar but incompatible data models, add compatibility
    properties to the newer model rather than changing all consumers. The BaseSession
    in parsers/models.py gained properties like 'id' (aliasing session_id), 'start_time'
    (aliasing timestamp), and 'tools_used' (converting tool_calls) to maintain compatibility
    with models/__init__.py:BaseSession consumers.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - compatibility
  - technical
  sample_count: 1
- pattern: workflow-reliability/*
  insights:
  - When an agent sends its final signal (done/approved/complete) and then terminates
    before the orchestrator acknowledges, the framework reports 'agents died' despite
    successful completion. The workflow recorded three successful signals (dev done
    at 14:04, QA approved at 14:06, watcher complete at 14:06) yet reported failure.
    Orchestrators should check for existing completion signals before declaring failure.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-reliability
  - technical
  sample_count: 1
- pattern: code-review/*
  insights:
  - "QA's initial 'needs_revision' signal identified that the dev's first implementation\
    \ was missing 6 required fields (task_description, signals, learnings, improvements,\
    \ quality_assessment, cycle_info). The dev then completed the full implementation\
    \ in under 6 minutes, and QA approved on second review. This tight feedback loop\
    \ (needs_revision \u2192 fix \u2192 approved in ~8 minutes) prevented shipping\
    \ incomplete work and demonstrates that structured QA review catches specification\
    \ gaps that dev agents miss."
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - code-review
  - process
  sample_count: 1
- pattern: dependencies/*
  insights:
  - 'Task required Click dependency but dev initially signaled done without it. QA
    caught this in first review cycle. Pattern: run ''uv sync'' or equivalent and
    verify imports work before claiming task completion. Dependencies are a common
    oversight in verification tasks.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - dependencies
  - technical
  sample_count: 1
- pattern: workflow-resilience/*
  insights:
  - When tmux sessions terminate unexpectedly, agents die without opportunity to save
    state or signal failure. This creates opaque failures reported as 'agents died'
    without diagnostic information. Long-running tasks are particularly vulnerable
    to this infrastructure failure mode.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-resilience
  - process
  sample_count: 1
- pattern: task-decomposition/*
  insights:
  - 'The task had exactly three acceptance criteria: (1) add --output argument with
    default, (2) create directory if missing, (3) print confirmation message. This
    atomic scope allowed dev to complete implementation quickly and QA to verify each
    criterion explicitly. Following the pattern from cycle-5, small focused tasks
    outperform monolithic implementations.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - task-decomposition
  - process
  sample_count: 1
- pattern: failure-recovery/*
  insights:
  - When cycle-4 'implement-cli-skeleton' failed, the system had already evolved a
    decomposition plan. Cycle-5 'add-analyze-subcommand-stub' succeeded with 186 tests
    passing. This validates that incremental task breakdown is an effective recovery
    strategy after infrastructure or scope failures.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - failure-recovery
  - process
  sample_count: 1
- pattern: performance/*
  insights:
  - When parsing file-discovery-based sources (like VerMAS scanning .vermas/ directories),
    implement a _parsed_dirs cache to track already-processed directories. Without
    this, scanning multiple files from the same source creates duplicate sessions
    in aggregated results. Add reset_cache() function for test isolation.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - performance
  - technical
  sample_count: 1
- pattern: debugging/*
  insights:
  - "For the 8th consecutive time, the merge from task branch to main dropped all\
    \ src/ and tests/ changes, producing an artifact-only commit (c41a3a3) containing\
    \ only .vermas/ state files, .coverage, and .worktrees/ entries. The branch (5590645)\
    \ retains the +849 LOC. The root cause appears to be in the automated merge/commit\
    \ process that constructs the main commit \u2014 it selectively stages .vermas/\
    \ artifacts but not source code. This is now the project's #1 systemic issue with\
    \ ~2,041 LOC stranded across 4 branches."
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - debugging
  - process
  sample_count: 1
- pattern: integration/*
  insights:
  - When adding new session sources to a discovery system, update SESSION_PATTERNS
    to include the new directory patterns (.claude/, .codex/, .vermas/) AND update
    parse_session_file() dispatch logic to route to the correct parser based on file
    path context. QA should explicitly verify both discovery and parsing for each
    new source.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - integration
  - technical
  sample_count: 1
- pattern: task-planning/*
  insights:
  - This workflow attempted 'implement-cli-skeleton' when cli.py already exists in
    git with multiple prior commits. Task backlog systems must query git (git ls-files
    --error-unmatch <deliverable>) before spawning agent workflows. Tasks targeting
    existing files should be auto-converted to 'enhance' or 'fix' tasks, or auto-closed
    entirely.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - task-planning
  - process
  sample_count: 1
- pattern: workflow-lifecycle/*
  insights:
  - At 4666 seconds (77+ minutes), all three agents (watcher, dev, qa) died simultaneously,
    indicating tmux session termination rather than individual agent failures. Workflows
    exceeding 30 minutes should implement session keepalive mechanisms or checkpoint-based
    recovery to survive infrastructure interruptions.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-lifecycle
  - process
  sample_count: 1
- pattern: specification-compliance/*
  insights:
  - Dev initially implemented with typer/rich/pydantic when spec explicitly required
    click>=8.0. Over-building creates drift from requirements and extra rework during
    QA. Always start with the minimal spec (dependencies explicitly listed in task
    definition) and resist adding conveniences not specified in requirements.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - specification-compliance
  - process
  sample_count: 1
- pattern: task-validation/*
  insights:
  - The obsidian formatter was marked as status:done in the task backlog (implement-obsidian-formatter.md)
    yet a new workflow attempted to add it. Task orchestration should cross-reference
    backlog status and git file existence before spawning workflows. The existing
    file tracking showed obsidian.py committed in multiple prior commits.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - task-validation
  - process
  sample_count: 1
- pattern: error-diagnostics/*
  insights:
  - 'The error ''agents died. Dead roles: [watcher, dev, qa]'' provides no information
    about why the tmux session ended (timeout, user action, resource exhaustion, or
    crash). Adding pre-termination hooks or periodic state snapshots would enable
    root cause analysis and distinguish recoverable from fatal failures.'
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - error-diagnostics
  - technical
  sample_count: 1
- pattern: task-backlog/*
  insights:
  - Tasks targeting files that already exist in git should be automatically converted
    to 'enhance' or 'fix' variants, or auto-closed with explanation. This prevents
    wasted compute on obsolete work and aligns the backlog with actual codebase state.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - task-backlog
  - process
  sample_count: 1
- pattern: workflow-coordination/*
  insights:
  - This model unification task was correctly sequenced as the first task in a 4-task
    cycle, since the other 3 tasks (formatter, analyze subcommand, integration tests)
    depended on the unified model. The 678-second completion time (including one revision
    cycle) was fast enough to unblock dependent workflows. Breaking the merge-drops-source
    pattern (8 prior occurrences) by committing directly to main rather than using
    branches eliminated the merge failure risk.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-coordination
  - process
  sample_count: 1
- pattern: cli-development/*
  insights:
  - 'When a task requires importing modules for future use but linters flag them as
    unused, create a registry pattern (like PARSERS = {''claude'': ClaudeParser, ...})
    that references the imports. This documents the intended mapping while satisfying
    static analysis.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - cli-development
  - technical
  sample_count: 1
- pattern: workflow/*
  insights:
  - "The workflow produces increasingly sophisticated code (849 LOC with 26 tests,\
    \ 92% coverage, QA-approved) yet consistently fails at the final merge step. The\
    \ development and QA phases work well \u2014 needs_revision drives improvement,\
    \ done signal accurately reflects work, approval validates quality \u2014 but\
    \ the merge automation negates all value by producing artifact-only commits. The\
    \ workflow's weakest link is not code quality but deployment to main."
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow
  - process
  sample_count: 1
- pattern: workflow-signals/*
  insights:
  - The pre-signal-check.sh script (fixed in 33f3b78 to check HEAD~1..HEAD) still
    cannot detect when a completion commit omits source changes that exist on the
    task branch. It only checks if the latest commit has source diffs vs main, not
    whether the task branch's source changes were included. A new check comparing
    'git diff main..task-branch -- src/ tests/' would catch this.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-signals
  - technical
  sample_count: 1
- pattern: discovery/*
  insights:
  - Before implementing any task, agents should first check if the deliverable already
    exists. In this workflow, the dev agent correctly identified that the directory
    structure was already present and reported verification instead of attempting
    recreation. This avoids duplicate work and maintains idempotency.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - discovery
  - process
  sample_count: 1
- pattern: recovery/*
  insights:
  - Even when workflow orchestration fails, code written in git worktrees is preserved
    and can be recovered. The investigation found a complete implementation with passing
    tests in .worktrees/implement-claude-parser/ that just needed to be committed.
    Always check worktrees before re-implementing failed tasks.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - recovery
  - technical
  sample_count: 1
- pattern: observability/*
  insights:
  - 'Workflow failures can occur at multiple levels: code implementation, test execution,
    commit/merge operations, or orchestration (agent registration, signal delivery).
    The root cause analysis identified MCP connection refused errors and missing agent
    registrations as orchestration issues, not code issues.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - observability
  - process
  sample_count: 1
- pattern: resilience/*
  insights:
  - When agents complete work but fail to signal completion, the work is lost if not
    committed. Consider implementing WIP (work-in-progress) commits before signaling
    done, so that even if signaling fails, the implementation is preserved in git
    history for recovery.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - resilience
  - process
  sample_count: 1
- pattern: git/*
  insights:
  - Always run explicit `git add` for deliverable files and verify with `git ls-files
    --error-unmatch` before signaling done. The common failure mode is creating files
    in the working directory without committing them, which breaks the 'done means
    committed to main' principle.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - git
  - technical
  sample_count: 1
- pattern: process/*
  insights:
  - 'Despite explicit tracking in MEMORY.md and review meetings mandating ''agenda
    item #1: status of prior action items'', critical fixes like act-71835fc6 (fix
    merge process) and act-1231eb07 (recover branch code) remain unexecuted for 3+
    cycles. The merge-drops-source bug keeps recurring because the fix action item
    never gets scheduled as an actual task. The planning phase creates new tasks instead
    of drawing from the action item backlog.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - process
  - process
  sample_count: 1
- pattern: workflow-management/*
  insights:
  - This workflow completed successfully (QA approved, commit made) but was reported
    as 'failure' due to 'agents died' when tmux sessions ended. Workflow success should
    be determined by signal state (complete/approved) rather than agent session liveness.
    Final state showed watcher reporting successful completion.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-management
  - process
  sample_count: 1
- pattern: qa-feedback/*
  insights:
  - 'QA provided specific, actionable feedback in each needs_revision signal: exact
    file paths, exact issue (ruff F401), and exact requirement reference. This specificity
    enabled dev to address issues in under 2 minutes per cycle rather than requiring
    clarification rounds.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - qa-feedback
  - process
  sample_count: 1
- pattern: workflow-efficiency/*
  insights:
  - The 636-second total duration included initial implementation plus two QA feedback
    cycles. Signal-based communication (done, needs_revision, done, needs_revision,
    done, approved, complete) kept context clear and transitions fast without synchronous
    meetings.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-efficiency
  - process
  sample_count: 1
- pattern: gate-0-validation/*
  insights:
  - The task 'add-obsidian-formatter' targeted src/session_insights/formatters/obsidian.py
    which already exists as a 10KB file with 17KB of compiled bytecode. Running 'git
    ls-files --error-unmatch src/session_insights/formatters/obsidian.py' before workflow
    launch would have detected this immediately. This is the same Gate 0 failure pattern
    observed in cycles 5-12.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - gate-0-validation
  - process
  sample_count: 1
- pattern: agent-reliability/*
  insights:
  - QA agent signaled 'approved' at 14:56:11, then dev signaled 'done' at 14:57:22,
    watcher signaled 'complete' at 14:57:47. Yet workflow failed because QA agent
    died afterward. The orchestrator should treat post-completion agent death differently
    than mid-task failure, preserving the success state.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - agent-reliability
  - process
  sample_count: 1
- pattern: documentation/*
  insights:
  - The diagnostic report included clear verification steps (test import without dev
    deps, test CLI execution, run test suite) that allow QA or future developers to
    confirm fixes work. This makes the diagnostic actionable rather than just informational.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - documentation
  - technical
  sample_count: 1
- pattern: pydantic/*
  insights:
  - When a Pydantic subclass needs different calculation logic than its base class
    property, add an explicit property override in the subclass. VermasSession.duration_minutes
    was added to override BaseSession's calculation that returned 0/Unknown for sessions
    with different time field semantics.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - pydantic
  - technical
  sample_count: 1
- pattern: validation/*
  insights:
  - 'Effective CLI validation verifies: (1) entry point executes without import errors,
    (2) parser produces expected session counts from real data, (3) output format
    has valid structure (YAML frontmatter, markdown), (4) aggregations calculate correctly
    (durations, counts). This 4-point check validated parse_success_rate and obsidian_compatibility
    KPIs.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - validation
  - process
  sample_count: 1
- pattern: cli/*
  insights:
  - The sessions command outputs structured JSON (session_count, total_messages, date_range,
    sources) rather than formatted text. This enables piping output to other tools
    (jq, scripts) and makes the CLI composable. For discovery/listing commands, JSON
    is preferable to human-readable output.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - cli
  - technical
  sample_count: 1
- pattern: task-design/*
  insights:
  - When a task specifies 'implement X' but X already exists (different framework/approach),
    the dev agent successfully pivoted from 'create with Click' to 'fix existing Typer
    entry point'. This preserved working code and avoided introducing regressions.
    Tasks should include a discovery step to check existing state before prescribing
    implementation details.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - task-design
  - process
  sample_count: 1
- pattern: gate-checking/*
  insights:
  - Before starting an implementation task, Gate 0 must confirm the deliverable does
    not already exist in the codebase. In this workflow, the 'implement-analyze-command'
    task failed because the analyze command already existed from cycle 16 (commit
    5a0f625). A simple `git ls-files --error-unmatch` check or code search would have
    caught this before any work began.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - gate-checking
  - process
  sample_count: 1
- pattern: commits/*
  insights:
  - A commit that modifies only workflow artifacts (.yaml, .md, __pycache__) without
    changing any source code or test files is an artifact-only commit. Commit d2194b7
    claimed to 'Implement analyze CLI command with full pipeline' but contained 0
    src/test changes. Post-execution verification must diff src/ and tests/ directories
    against the parent commit, not against main, to catch this pattern.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - commits
  - process
  sample_count: 1
- pattern: action-items/*
  insights:
  - Action items act-2d5f5e36 (fix pre-signal-check.sh) and act-4b987d19 (create pre-task-check.sh)
    would have prevented this failure but remained unexecuted for 3+ cycles. The systemic
    issue is that task planners create new tasks instead of pulling from the action
    item backlog, causing the same failure modes to recur. Future workflows should
    check pending action items before planning new work.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - action-items
  - process
  sample_count: 1
- pattern: workflow-design/*
  insights:
  - "This workflow completed with 'success' status in 362 seconds, but the actual\
    \ outcome was a failed delivery \u2014 an artifact-only commit with zero source\
    \ code changes. Workflow orchestration should distinguish between process completion\
    \ (all steps ran) and value delivery (deliverables contain real changes). A post-merge\
    \ source diff check is essential."
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-design
  - process
  sample_count: 1
- pattern: deployment/*
  insights:
  - Main commit 81bd567 has 0 src/test changes despite task branch 7ba531c having
    +375 LOC (179 in obsidian.py, 225 in tests). The merge process creates a commit
    with .vermas/ artifacts but fails to include actual source changes. This is the
    6th documented occurrence (cycles 3, 16, C8, M2e-C3, and now this). The pattern
    persists because the fix (act-71835fc6) has never been executed despite being
    a pending action item for multiple cycles.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - deployment
  - process
  sample_count: 1
- pattern: workflow-automation/*
  insights:
  - 'Three action items from prior reviews (act-8c5932eb: .gitignore cleanup, act-2d5f5e36:
    pre-signal-check.sh fix, coverage fix) were finally executed as direct commits
    (8269907, 33f3b78, eb44c93) immediately after the M2e-C3 review. This broke the
    pattern of action items never being executed by treating them as standalone fixes
    rather than routing through the full workflow cycle.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-automation
  - process
  sample_count: 1
- pattern: implementation/*
  insights:
  - The dev agent produced a well-structured analyze subcommand with compute_richness_score(),
    compute_field_coverage(), --stats-only flag for JSON output, and comprehensive
    tests (+327 LOC tests across 3 files). The implementation follows established
    patterns (Typer + Rich) and properly handles edge cases (UTC normalization, file
    vs directory input, unparseable sessions). This quality of work is wasted when
    it doesn't reach main.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - implementation
  - technical
  sample_count: 1
- pattern: refactoring/*
  insights:
  - 'The successful approach was: (1) move shared type definitions from the specialized
    module (vermas.py) to the base module (models.py), (2) extend BaseSession with
    new fields using Optional/default-empty-list patterns, (3) update the specialized
    class to inherit rather than redefine, (4) add model_post_init() to auto-derive
    computed fields. This 4-step pattern achieved +141/-77 LOC (net +64) with zero
    test regressions across 218 tests.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - refactoring
  - technical
  sample_count: 1
