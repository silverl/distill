patterns:
- pattern: architecture/*
  insights:
  - The formatter extracts structured sections (What Was Asked, Tool Usage Summary,
    Accomplishments, Key Decisions) from raw conversation turns using pattern matching
    and purpose inference maps. The _infer_tool_purpose() method maps 10 known tool
    names to human-readable descriptions with a 'General tool usage' fallback. This
    is a reusable pattern for transforming raw agent traces into readable reports.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - architecture
  - technical
  sample_count: 1
- pattern: git-workflow/*
  insights:
  - 'When code exists in git worktrees but was never committed to main, recover it
    by: (1) copying files from worktree to main, (2) running tests to verify functionality,
    (3) using ''git add'' explicitly on each deliverable file, (4) verifying tracking
    with ''git ls-files --error-unmatch'', (5) committing with descriptive message
    referencing the original action item IDs. This workflow recovered 2000+ lines
    of parser code (VerMAS: 830 lines, Codex: 514 lines) plus 1793 lines of tests.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - git-workflow
  - process
  sample_count: 1
- pattern: verification/*
  insights:
  - The pre-signal-check.sh script's artifact-only detection compares main..HEAD,
    which passes if ANY prior commit on the branch has src/tests changes. This allows
    artifact-only commits to slip through when prior successful commits exist. The
    fix is to compare HEAD~1..HEAD to verify the most recent commit itself contains
    source changes.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - verification
  - technical
  sample_count: 1
- pattern: testing/*
  insights:
  - "Dev anticipated the test failures QA later flagged (include_conversation default\
    \ behavior) and fixed them before the first done signal by using include_conversation=False\
    \ in relevant tests. This proactive approach meant QA's needs_revision was actually\
    \ a false alarm \u2014 the dev had already addressed the concern. Writing tests\
    \ alongside implementation catches interface mismatches early."
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - testing
  - technical
  sample_count: 1
- pattern: code-recovery/*
  insights:
  - When integrating components developed in git worktrees, first verify and commit
    the code to main before wiring them into the core system. This workflow successfully
    recovered 1,140 lines of Codex parser code and 2,030 lines of VerMAS parser code
    that existed in worktrees but were never committed. The recovery step (commits
    d9e3b74, becde1e) preceded the integration step (commit 9d038df).
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - code-recovery
  - process
  sample_count: 1
- pattern: infrastructure/*
  insights:
  - 'The error message ''agents died. Dead roles: [watcher, dev, qa]'' provides no
    information about why the tmux session ended (timeout, user action, resource exhaustion,
    or system restart). Adding diagnostic logging before session teardown would enable
    root cause analysis.'
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - infrastructure
  - technical
  sample_count: 1
- pattern: error-handling/*
  insights:
  - The 'agents died' error should first check if the workflow has already completed
    via signals. In this case, all three roles had signaled success within 3 minutes
    (14:04-14:06) before the QA agent died. A pre-failure signal check would have
    correctly identified this as a successful completion with agent cleanup issue
    rather than a failed workflow.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - error-handling
  - technical
  sample_count: 1
- pattern: compatibility/*
  insights:
  - When two parts of a system use similar but incompatible data models, add compatibility
    properties to the newer model rather than changing all consumers. The BaseSession
    in parsers/models.py gained properties like 'id' (aliasing session_id), 'start_time'
    (aliasing timestamp), and 'tools_used' (converting tool_calls) to maintain compatibility
    with models/__init__.py:BaseSession consumers.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - compatibility
  - technical
  sample_count: 1
- pattern: workflow-reliability/*
  insights:
  - When an agent sends its final signal (done/approved/complete) and then terminates
    before the orchestrator acknowledges, the framework reports 'agents died' despite
    successful completion. The workflow recorded three successful signals (dev done
    at 14:04, QA approved at 14:06, watcher complete at 14:06) yet reported failure.
    Orchestrators should check for existing completion signals before declaring failure.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-reliability
  - technical
  sample_count: 1
- pattern: code-review/*
  insights:
  - "The dev-QA interaction was efficient: dev signaled done, QA flagged 2 test issues\
    \ within 21 seconds, dev clarified tests were already fixed (43 seconds), QA verified\
    \ and approved (2 minutes later). Total resolution: ~3 minutes for the entire\
    \ review cycle. The signal-based workflow (done \u2192 needs_revision \u2192 done\
    \ \u2192 approved) created a clear audit trail with specific, actionable feedback."
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - code-review
  - process
  sample_count: 1
- pattern: dependencies/*
  insights:
  - 'Task required Click dependency but dev initially signaled done without it. QA
    caught this in first review cycle. Pattern: run ''uv sync'' or equivalent and
    verify imports work before claiming task completion. Dependencies are a common
    oversight in verification tasks.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - dependencies
  - technical
  sample_count: 1
- pattern: workflow-resilience/*
  insights:
  - When tmux sessions terminate unexpectedly, agents die without opportunity to save
    state or signal failure. This creates opaque failures reported as 'agents died'
    without diagnostic information. Long-running tasks are particularly vulnerable
    to this infrastructure failure mode.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-resilience
  - process
  sample_count: 1
- pattern: task-decomposition/*
  insights:
  - 'The task had exactly three acceptance criteria: (1) add --output argument with
    default, (2) create directory if missing, (3) print confirmation message. This
    atomic scope allowed dev to complete implementation quickly and QA to verify each
    criterion explicitly. Following the pattern from cycle-5, small focused tasks
    outperform monolithic implementations.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - task-decomposition
  - process
  sample_count: 1
- pattern: failure-recovery/*
  insights:
  - When cycle-4 'implement-cli-skeleton' failed, the system had already evolved a
    decomposition plan. Cycle-5 'add-analyze-subcommand-stub' succeeded with 186 tests
    passing. This validates that incremental task breakdown is an effective recovery
    strategy after infrastructure or scope failures.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - failure-recovery
  - process
  sample_count: 1
- pattern: performance/*
  insights:
  - When parsing file-discovery-based sources (like VerMAS scanning .vermas/ directories),
    implement a _parsed_dirs cache to track already-processed directories. Without
    this, scanning multiple files from the same source creates duplicate sessions
    in aggregated results. Add reset_cache() function for test isolation.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - performance
  - technical
  sample_count: 1
- pattern: debugging/*
  insights:
  - 'When using Typer with pyproject.toml console_scripts, pointing the entrypoint
    directly at the Typer app object or a callback function produces no output. The
    fix is to create a run() function that calls app() and point the entrypoint at
    that wrapper. This is a common Typer pitfall: `session_insights.cli:run` where
    run() calls app().'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - debugging
  - technical
  sample_count: 1
- pattern: integration/*
  insights:
  - When adding new session sources to a discovery system, update SESSION_PATTERNS
    to include the new directory patterns (.claude/, .codex/, .vermas/) AND update
    parse_session_file() dispatch logic to route to the correct parser based on file
    path context. QA should explicitly verify both discovery and parsing for each
    new source.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - integration
  - technical
  sample_count: 1
- pattern: task-planning/*
  insights:
  - This workflow attempted 'implement-cli-skeleton' when cli.py already exists in
    git with multiple prior commits. Task backlog systems must query git (git ls-files
    --error-unmatch <deliverable>) before spawning agent workflows. Tasks targeting
    existing files should be auto-converted to 'enhance' or 'fix' tasks, or auto-closed
    entirely.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - task-planning
  - process
  sample_count: 1
- pattern: workflow-lifecycle/*
  insights:
  - At 4666 seconds (77+ minutes), all three agents (watcher, dev, qa) died simultaneously,
    indicating tmux session termination rather than individual agent failures. Workflows
    exceeding 30 minutes should implement session keepalive mechanisms or checkpoint-based
    recovery to survive infrastructure interruptions.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-lifecycle
  - process
  sample_count: 1
- pattern: specification-compliance/*
  insights:
  - Dev initially implemented with typer/rich/pydantic when spec explicitly required
    click>=8.0. Over-building creates drift from requirements and extra rework during
    QA. Always start with the minimal spec (dependencies explicitly listed in task
    definition) and resist adding conveniences not specified in requirements.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - specification-compliance
  - process
  sample_count: 1
- pattern: task-validation/*
  insights:
  - The obsidian formatter was marked as status:done in the task backlog (implement-obsidian-formatter.md)
    yet a new workflow attempted to add it. Task orchestration should cross-reference
    backlog status and git file existence before spawning workflows. The existing
    file tracking showed obsidian.py committed in multiple prior commits.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - task-validation
  - process
  sample_count: 1
- pattern: error-diagnostics/*
  insights:
  - 'The error ''agents died. Dead roles: [watcher, dev, qa]'' provides no information
    about why the tmux session ended (timeout, user action, resource exhaustion, or
    crash). Adding pre-termination hooks or periodic state snapshots would enable
    root cause analysis and distinguish recoverable from fatal failures.'
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - error-diagnostics
  - technical
  sample_count: 1
- pattern: task-backlog/*
  insights:
  - Tasks targeting files that already exist in git should be automatically converted
    to 'enhance' or 'fix' variants, or auto-closed with explanation. This prevents
    wasted compute on obsolete work and aligns the backlog with actual codebase state.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - task-backlog
  - process
  sample_count: 1
- pattern: workflow-coordination/*
  insights:
  - The dev agent sent 3 consecutive 'done' signals (signals 4-6) repeating 'already
    fixed' and 'already committed' for the same entrypoint fix. This pattern of redundant
    signaling wastes time and suggests the agent is uncertain whether its prior fix
    was received. A single done signal with clear evidence (commit hash, test output)
    is sufficient and more efficient.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-coordination
  - process
  sample_count: 1
- pattern: cli-development/*
  insights:
  - 'When a task requires importing modules for future use but linters flag them as
    unused, create a registry pattern (like PARSERS = {''claude'': ClaudeParser, ...})
    that references the imports. This documents the intended mapping while satisfying
    static analysis.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - cli-development
  - technical
  sample_count: 1
- pattern: workflow/*
  insights:
  - The entire workflow completed in 362 seconds with only 2 minutes between dev's
    done signal (17:55:28) and QA's approval (17:57:22). For a task claiming 'full
    pipeline implementation,' this timeline is too fast for meaningful code review.
    Fast signal-to-approval times on complex tasks correlate with artifact-only or
    low-value outcomes in this project's history. A minimum review time threshold
    or mandatory diff-inspection step would prevent rubber-stamp approvals.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow
  - process
  sample_count: 1
- pattern: workflow-signals/*
  insights:
  - Both dev and QA used descriptive signal messages explaining exactly what was done
    or what needed revision. QA's 'needs_revision' messages specified the exact discrepancy
    ('Click default vs spec'), allowing dev to fix precisely without back-and-forth
    clarification.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-signals
  - process
  sample_count: 1
- pattern: discovery/*
  insights:
  - Before implementing any task, agents should first check if the deliverable already
    exists. In this workflow, the dev agent correctly identified that the directory
    structure was already present and reported verification instead of attempting
    recreation. This avoids duplicate work and maintains idempotency.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - discovery
  - process
  sample_count: 1
- pattern: recovery/*
  insights:
  - Even when workflow orchestration fails, code written in git worktrees is preserved
    and can be recovered. The investigation found a complete implementation with passing
    tests in .worktrees/implement-claude-parser/ that just needed to be committed.
    Always check worktrees before re-implementing failed tasks.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - recovery
  - technical
  sample_count: 1
- pattern: observability/*
  insights:
  - 'Workflow failures can occur at multiple levels: code implementation, test execution,
    commit/merge operations, or orchestration (agent registration, signal delivery).
    The root cause analysis identified MCP connection refused errors and missing agent
    registrations as orchestration issues, not code issues.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - observability
  - process
  sample_count: 1
- pattern: resilience/*
  insights:
  - When agents complete work but fail to signal completion, the work is lost if not
    committed. Consider implementing WIP (work-in-progress) commits before signaling
    done, so that even if signaling fails, the implementation is preserved in git
    history for recovery.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - resilience
  - process
  sample_count: 1
- pattern: git/*
  insights:
  - Always run explicit `git add` for deliverable files and verify with `git ls-files
    --error-unmatch` before signaling done. The common failure mode is creating files
    in the working directory without committing them, which breaks the 'done means
    committed to main' principle.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - git
  - technical
  sample_count: 1
- pattern: process/*
  insights:
  - 'Despite explicit tracking in MEMORY.md and review meetings mandating ''agenda
    item #1: status of prior action items'', critical fixes like act-71835fc6 (fix
    merge process) and act-1231eb07 (recover branch code) remain unexecuted for 3+
    cycles. The merge-drops-source bug keeps recurring because the fix action item
    never gets scheduled as an actual task. The planning phase creates new tasks instead
    of drawing from the action item backlog.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - process
  - process
  sample_count: 1
- pattern: workflow-management/*
  insights:
  - This workflow completed successfully (QA approved, commit made) but was reported
    as 'failure' due to 'agents died' when tmux sessions ended. Workflow success should
    be determined by signal state (complete/approved) rather than agent session liveness.
    Final state showed watcher reporting successful completion.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-management
  - process
  sample_count: 1
- pattern: qa-feedback/*
  insights:
  - 'QA provided specific, actionable feedback in each needs_revision signal: exact
    file paths, exact issue (ruff F401), and exact requirement reference. This specificity
    enabled dev to address issues in under 2 minutes per cycle rather than requiring
    clarification rounds.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - qa-feedback
  - process
  sample_count: 1
- pattern: workflow-efficiency/*
  insights:
  - The 636-second total duration included initial implementation plus two QA feedback
    cycles. Signal-based communication (done, needs_revision, done, needs_revision,
    done, approved, complete) kept context clear and transitions fast without synchronous
    meetings.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-efficiency
  - process
  sample_count: 1
- pattern: gate-0-validation/*
  insights:
  - The task 'add-obsidian-formatter' targeted src/session_insights/formatters/obsidian.py
    which already exists as a 10KB file with 17KB of compiled bytecode. Running 'git
    ls-files --error-unmatch src/session_insights/formatters/obsidian.py' before workflow
    launch would have detected this immediately. This is the same Gate 0 failure pattern
    observed in cycles 5-12.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - gate-0-validation
  - process
  sample_count: 1
- pattern: agent-reliability/*
  insights:
  - QA agent signaled 'approved' at 14:56:11, then dev signaled 'done' at 14:57:22,
    watcher signaled 'complete' at 14:57:47. Yet workflow failed because QA agent
    died afterward. The orchestrator should treat post-completion agent death differently
    than mid-task failure, preserving the success state.
  revision_rate: null
  success_rate: 0.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - agent-reliability
  - process
  sample_count: 1
- pattern: documentation/*
  insights:
  - The diagnostic report included clear verification steps (test import without dev
    deps, test CLI execution, run test suite) that allow QA or future developers to
    confirm fixes work. This makes the diagnostic actionable rather than just informational.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - documentation
  - technical
  sample_count: 1
- pattern: pydantic/*
  insights:
  - When a Pydantic subclass needs different calculation logic than its base class
    property, add an explicit property override in the subclass. VermasSession.duration_minutes
    was added to override BaseSession's calculation that returned 0/Unknown for sessions
    with different time field semantics.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - pydantic
  - technical
  sample_count: 1
- pattern: validation/*
  insights:
  - 'Effective CLI validation verifies: (1) entry point executes without import errors,
    (2) parser produces expected session counts from real data, (3) output format
    has valid structure (YAML frontmatter, markdown), (4) aggregations calculate correctly
    (durations, counts). This 4-point check validated parse_success_rate and obsidian_compatibility
    KPIs.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - validation
  - process
  sample_count: 1
- pattern: cli/*
  insights:
  - The sessions command outputs structured JSON (session_count, total_messages, date_range,
    sources) rather than formatted text. This enables piping output to other tools
    (jq, scripts) and makes the CLI composable. For discovery/listing commands, JSON
    is preferable to human-readable output.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - cli
  - technical
  sample_count: 1
- pattern: task-design/*
  insights:
  - When a task specifies 'implement X' but X already exists (different framework/approach),
    the dev agent successfully pivoted from 'create with Click' to 'fix existing Typer
    entry point'. This preserved working code and avoided introducing regressions.
    Tasks should include a discovery step to check existing state before prescribing
    implementation details.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - task-design
  - process
  sample_count: 1
- pattern: gate-checking/*
  insights:
  - Before starting an implementation task, Gate 0 must confirm the deliverable does
    not already exist in the codebase. In this workflow, the 'implement-analyze-command'
    task failed because the analyze command already existed from cycle 16 (commit
    5a0f625). A simple `git ls-files --error-unmatch` check or code search would have
    caught this before any work began.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - gate-checking
  - process
  sample_count: 1
- pattern: commits/*
  insights:
  - A commit that modifies only workflow artifacts (.yaml, .md, __pycache__) without
    changing any source code or test files is an artifact-only commit. Commit d2194b7
    claimed to 'Implement analyze CLI command with full pipeline' but contained 0
    src/test changes. Post-execution verification must diff src/ and tests/ directories
    against the parent commit, not against main, to catch this pattern.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - commits
  - process
  sample_count: 1
- pattern: action-items/*
  insights:
  - Action items act-2d5f5e36 (fix pre-signal-check.sh) and act-4b987d19 (create pre-task-check.sh)
    would have prevented this failure but remained unexecuted for 3+ cycles. The systemic
    issue is that task planners create new tasks instead of pulling from the action
    item backlog, causing the same failure modes to recur. Future workflows should
    check pending action items before planning new work.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - action-items
  - process
  sample_count: 1
- pattern: workflow-design/*
  insights:
  - "This workflow completed with 'success' status in 362 seconds, but the actual\
    \ outcome was a failed delivery \u2014 an artifact-only commit with zero source\
    \ code changes. Workflow orchestration should distinguish between process completion\
    \ (all steps ran) and value delivery (deliverables contain real changes). A post-merge\
    \ source diff check is essential."
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-design
  - process
  sample_count: 1
- pattern: deployment/*
  insights:
  - Main commit 81bd567 has 0 src/test changes despite task branch 7ba531c having
    +375 LOC (179 in obsidian.py, 225 in tests). The merge process creates a commit
    with .vermas/ artifacts but fails to include actual source changes. This is the
    6th documented occurrence (cycles 3, 16, C8, M2e-C3, and now this). The pattern
    persists because the fix (act-71835fc6) has never been executed despite being
    a pending action item for multiple cycles.
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - deployment
  - process
  sample_count: 1
- pattern: workflow-automation/*
  insights:
  - 'Three action items from prior reviews (act-8c5932eb: .gitignore cleanup, act-2d5f5e36:
    pre-signal-check.sh fix, coverage fix) were finally executed as direct commits
    (8269907, 33f3b78, eb44c93) immediately after the M2e-C3 review. This broke the
    pattern of action items never being executed by treating them as standalone fixes
    rather than routing through the full workflow cycle.'
  revision_rate: null
  success_rate: 1.0
  avg_duration: null
  recommended_workflow: null
  tags:
  - workflow-automation
  - process
  sample_count: 1
